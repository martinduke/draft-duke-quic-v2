---
title: QUIC Version 2
abbrev: QUICv2
docname: draft-ietf-quic-v2-latest
category: std
v: 3
submissiontype: IETF
area: "Transport"
workgroup: "QUIC"
venue:
  group: "QUIC"
  type: "Working Group"
  mail: "quic@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/browse/quic/"
  github: "quicwg/quic-v2"
  latest: "https://quicwg.org/quic-v2/draft-ietf-quic-v2.html"

author:
  -
    ins: M. Duke
    name: Martin Duke
    org: Google LLC
    email: martin.h.duke@gmail.com

normative:
  QUIC: RFC9000
  QUIC-TLS: RFC9001

informative:
  H3:
    =: RFC9114
    display: HTTP/3


--- abstract

This document specifies QUIC version 2, which is identical to QUIC version 1
except for some trivial details. Its purpose is to combat various ossification
vectors and exercise the version negotiation framework. It also serves as a
template for the minimum changes in any future version of QUIC.

Note that "version 2" is an informal name for this proposal that indicates it
is the second standards-track QUIC version. The protocol specified here uses a
version number other than 2 in the wire image, in order to minimize ossification
risk.

--- middle

# Introduction

QUIC version 1{{QUIC}} has numerous extension points, including the version
number that occupies the second through fifth bytes of every long header (see
{{?QUIC-INVARIANTS=RFC8999}}). If experimental versions are rare, and QUIC
version 1 constitutes the vast majority of QUIC traffic, there is the potential
for middleboxes to ossify on the version bytes always being 0x00000001.

In QUIC version 1, Initial packets are encrypted with the version-specific salt
as described in {{Section 5.2 of QUIC-TLS}}. Protecting Initial packets in this
way allows observers to inspect their contents, which includes the TLS Client
Hello or Server Hello messages. Again, there is the potential for middleboxes to
ossify on the version 1 key derivation and packet formats.

Finally, {{!QUIC-VN=I-D.ietf-quic-version-negotiation}} provides two mechanisms
for endpoints to negotiate the QUIC version to use. The "incompatible" version
negotiation method can support switching from any QUIC version to any
other version with full generality, at the cost of an additional round-trip at
the start of the connection. "Compatible" version negotiation eliminates the
round-trip penalty but levies some restrictions on how much the two versions can
differ semantically.

QUIC version 2 is meant to mitigate ossification concerns and exercise the
version negotiation mechanisms. The changes provide an example of the minimum
set of changes necessary to specify a new QUIC version. However, note that the
choice of the version number on the wire is randomly chosen instead of "2", and
the two bits that identify each long header packet type are different from
version 1; both of these properties are meant to combat ossification and are not
strictly required of a new QUIC version.

Any endpoint that supports two versions needs to implement version negotiation
to protect against downgrade attacks.

# Conventions

{::boilerplate bcp14-tagged}

# Differences with QUIC Version 1

Except for a few differences, QUIC version 2 endpoints MUST implement the QUIC
version 1 specification as described in {{QUIC}}, {{QUIC-TLS}}, and
{{!QUIC-RECOVERY=RFC9002}}. The remainder of this section lists the differences.

## Version Field

The Version field of long headers is 0x5a8e301a. This was generated by taking
the first four bytes of the sha256sum of "QUICv2 version number."

> **RFC Editor's Note:**  Please remove the sentence below prior to publication
> of a final version of this document.

This version number will not change in subsequent versions of this draft,
unless there is a behavior change that breaks compatibility.

## Long Header Packet Types

All version 2 long header packet types are different. The Type field values are:

* Initial: 0b01
* 0-RTT: 0b10
* Handshake: 0b11
* Retry: 0b00

## Cryptography changes

The values below were chosen randomly.

### Initial Salt

The salt used to derive Initial keys in {{Section 5.2 of QUIC-TLS}} changes to:

~~~
initial_salt = 0x3a785fb8f3009837546c9e8570b6bac843e3e142
~~~

This is the first 20 bytes of the sha256sum of "QUICv2 salt."

### HKDF Labels

> **RFC Editor's Note:**  Please ensure that the strings in quotes are not split
> up in a line break in this section.

The labels used in {{QUIC-TLS}} to derive packet protection keys (Section
{{Section 5.1 of QUIC-TLS}}{:sectionFormat="bare"}), header protection keys
(Section {{Section 5.4 of QUIC-TLS}}{:sectionFormat="bare"}), Retry Integrity
Tag keys (Section {{Section 5.8 of QUIC-TLS}}{:sectionFormat="bare"}), and key
updates (Section {{Section 6.1 of QUIC-TLS}}{:sectionFormat="bare"}) change from
"quic key" to "quicv2 key", from "quic iv" to "quicv2 iv", from "quic hp" to
"quicv2 hp", and from "quic ku" to "quicv2 ku", to meet the guidance for new
versions in Section {{Section 9.6 of QUIC-TLS}}{:sectionFormat="bare"} of that
document.

### Retry Integrity Tag

The key and nonce used for the Retry Integrity Tag ({{Section 5.8 of QUIC-TLS}})
change to:

~~~
secret =
  0x66e90fdd03db030d5c80eda22a45456cf664e37f719251105953350726a609cd
key = 0xd42ce594316b516e9db972acf7656505
nonce = 0xac3aac3139c1f33b5c9b6091
~~~

The secret is the sha256sum of "QUICv2 Retry Secret". The key and nonce are
derived from this secret with the labels "quicv2 key" and "quicv2 iv",
respectively.


# Version Negotiation Considerations

QUIC version 2 is not intended to deprecate version 1. Endpoints that support
version 2 might continue support for version 1 to maximize compatibility with
other endpoints. In particular, HTTP clients often use Alt-Svc {{?RFC7838}} to
discover QUIC support. As this mechanism does not currently distinguish between
QUIC versions, HTTP servers SHOULD support multiple versions to reduce the
probability of incompatibility and the cost associated with QUIC version
negotiation or TCP fallback. For example, an origin advertising support for "h3"
in Alt-Svc should support QUIC version 1 as it was the original QUIC version
used by HTTP/3, and therefore some clients will only support that version.

Any QUIC endpoint that supports QUIC version 2 MUST send, process, and validate
the version_information transport parameter specified in {{QUIC-VN}} to prevent
version downgrade attacks.

Note that version 2 meets the {{QUIC-VN}} definition of a compatible version
with version 1, and version 1 is compatible with version 2. Therefore, servers
can use compatible negotiation to switch a connection between the two versions.
Endpoints that support both versions SHOULD support compatible version
negotiation to avoid a round trip.

## Compatible Negotiation Requirements

Compatible version negotiation between versions 1 and 2 follow the same
requirements in either direction. This section uses the terms "original
version" and "negotiated version" from {{QUIC-VN}}.

If the server sends a Retry packet, it MUST use the original version. The
client ignores Retry packets using other versions. The client MUST NOT use a
different version in the subsequent Initial packet that contains the Retry
token. The server MAY encode the QUIC version in its Retry token to validate
that the client did not switch versions, and drop the packet if it switched,
to enforce client compliance.

QUIC version 2 uses the same transport parameters to authenticate the Retry as
QUIC version 1. After switching to a negotiated version after a Retry, the
server MUST include the relevant transport parameters to validate that the
server sent the Retry and the connection IDs used in the exchange, as described
in {{Section 7.3 of QUIC}}.

The server cannot send CRYPTO frames until it has processed the client's
transport parameters. The server MUST send all CRYPTO frames using
the negotiated version.

The client learns the negotiated version by observing the first long header
Version field that differs from the original version. If the client receives a
CRYPTO frame from the server in the original version, that indicates that the
negotiated version is equal to the original version.

Before the server is able to process transport parameters from the client, it
might need to respond to Initial packets from the client. For these packets, the
server uses the original version.

Once the client has learned the negotiated version, it SHOULD send subsequent
Initial packets using that version. The server MUST NOT discard its original
version Initial receive keys until it successfully processes a Handshake
packet with the negotiated version.

Both endpoints MUST send Handshake and 1-RTT packets using the negotiated
version. An endpoint MUST drop packets using any other version. Endpoints have
no need to generate the keying material that would allow them to decrypt or
authenticate such packets.

The client MUST NOT send 0-RTT packets using the negotiated version, even after
processing a packet of that version from the server. Servers can accept 0-RTT
and then process 0-RTT packets from the original version.

# TLS Resumption and NEW_TOKEN Tokens

TLS session tickets and NEW_TOKEN tokens are specific to the QUIC version of the
connection that provided them. Clients MUST NOT use a session ticket or token
from a QUIC version 1 connection to initiate a QUIC version 2 connection, or vice
versa.

Servers MUST validate the originating version of any session ticket or token and
not accept one issued from a different version. A rejected ticket results in
falling back to a full TLS handshake, without 0-RTT. A rejected token results in
the client address remaining unverified, which limits the amount of data the
server can send.

After compatible version negotiation, any resulting session ticket
maps to the negotiated version rather than original one.

# Ossification Considerations

QUIC version 2 provides protection against some forms of ossification. Devices
that assume that all long headers will encode version 1, or that the version 1
Initial key derivation formula will remain version-invariant, will not correctly
process version 2 packets.

However, many middleboxes, such as firewalls, focus on the first packet in a
connection, which will often remain in the version 1 format due to the
considerations above.

Clients interested in combating middlebox ossification can initiate a connection
using version 2 if they are either reasonably certain the server supports it, or
are willing to suffer a round-trip penalty if they are incorrect.  In
particular, a server that issues a session ticket for version 2 indicates an
intent to maintain version 2 support while the ticket remains valid, even if
support cannot be guaranteed.

# Applicability {#applicability}

This version of QUIC provides no change from QUIC version 1 relating to the
capabilities available to applications. Therefore, all Application Layer
Protocol Negotiation (ALPN) ({{?RFC7301}}) codepoints specified to operate over
QUIC version 1 can also operate over this version of QUIC. In particular, both
the "h3" {{H3}} and "doq" {{?RFC9250}} ALPNs can operate over
QUIC version 2.

Unless otherwise stated, all QUIC extensions defined to work with version 1 also
work with version 2.

# Security Considerations

QUIC version 2 introduces no changes to the security or privacy properties of
QUIC version 1.

The mandatory version negotiation mechanism guards against downgrade attacks,
but downgrades have no security implications, as the version properties are
identical.

Support for QUIC version 2 can help an observer to fingerprint both client and
server devices.

# IANA Considerations

This document requests that IANA add the following entry to the QUIC version
registry maintained at
<[](https://www.iana.org/assignments/quic/quic.xhtml#quic-versions)>.

Value:
: 0x709a50c4

Status:
: permanent

Specification:
: This Document

Change Controller:
: IETF

Contact:
: QUIC WG
{: spacing="compact"}

--- back

# Sample Packet Protection {#test-vectors}

This section shows examples of packet protection so that implementations can be
verified incrementally. Samples of Initial packets from both client and server
plus a Retry packet are defined. These packets use an 8-byte client-chosen
Destination Connection ID of 0x8394c8f03e515708. Some intermediate values are
included. All values are shown in hexadecimal.


## Keys

The labels generated during the execution of the HKDF-Expand-Label function
(that is, HkdfLabel.label) and part of the value given to the HKDF-Expand
function in order to produce its output are:

client in:  00200f746c73313320636c69656e7420696e00

server in:  00200f746c7331332073657276657220696e00

quicv2 key:  001010746c73313320717569637632206b657900

quicv2 iv:  000c0f746c7331332071756963763220697600

quicv2 hp:  00100f746c7331332071756963763220687000

The initial secret is common:

~~~
initial_secret = HKDF-Extract(initial_salt, cid)
    = ee8ff12f17c25b2fe9a0635f2382ca05
      81562432dcf0f4a85d8d707289f8a134
~~~

The secrets for protecting client packets are:

~~~
client_initial_secret
    = HKDF-Expand-Label(initial_secret, "client in", "", 32)
    = 435eea095c68d6fa1e20e5fabe185424
      3c063fe8b725971a03c4ab5b4f538df9

key = HKDF-Expand-Label(client_initial_secret, "quicv2 key", "", 16)
    = aa4d52dece9327560545163b328c0161

iv  = HKDF-Expand-Label(client_initial_secret, "quicv2 iv", "", 12)
    = dc307699029ece09f97f3f02

hp  = HKDF-Expand-Label(client_initial_secret, "quicv2 hp", "", 16)
    = c002264f632501ba6423ec6556fbb741
~~~

The secrets for protecting server packets are:

~~~
server_initial_secret
    = HKDF-Expand-Label(initial_secret, "server in", "", 32)
    = 471b1daaadaf784759dc9b739f869c6a
      bae232ea0f8d517f78f449c1dff63fff

key = HKDF-Expand-Label(server_initial_secret, "quicv2 key", "", 16)
    = 58936b4b085b87706a7aa77474557a6b

iv  = HKDF-Expand-Label(server_initial_secret, "quicv2 iv", "", 12)
    = 8164b78b18ac1929542bdafc

hp  = HKDF-Expand-Label(server_initial_secret, "quicv2 hp", "", 16)
    = f9da083f4e69a1a010cfb440cc7eac08
~~~


## Client Initial {#sample-client-initial}

The client sends an Initial packet.  The unprotected payload of this packet
contains the following CRYPTO frame, plus enough PADDING frames to make a
1162-byte payload:

~~~
060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868
04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578
616d706c652e636f6dff01000100000a 00080006001d00170018001000070005
04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba
baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400
0d0010000e0403050306030203080408 050806002d00020101001c0002400100
3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000
75300901100f088394c8f03e51570806 048000ffff
~~~

The unprotected header indicates a length of 1182 bytes: the 4-byte packet
number, 1162 bytes of frames, and the 16-byte authentication tag.  The header
includes the connection ID and a packet number of 2:

~~~
d35a8e301a088394c8f03e5157080000449e00000002
~~~

Protecting the payload produces output that is sampled for header protection.
Because the header uses a 4-byte packet number encoding, the first 16 bytes of
the protected payload is sampled and then applied to the header as follows:

~~~
sample = ed904c4dea96f6cb0d5d80f17df34daf

mask = AES-ECB(hp, sample)[0..4]
     = 029edabc92

header[0] ^= mask[0] & 0x0f
     = d1
header[18..21] ^= mask[1..4]
     = 9edabc90
header = d15a8e301a088394c8f03e5157080000449e9edabc90
~~~

The resulting protected packet is:

~~~
d15a8e301a088394c8f03e5157080000 449e9edabc90ed904c4dea96f6cb0d5d
80f17df34daff2c101505462e5ae4b31 34b678b184cafd927c1aad8c05128de5
b7d225cb54b830d6a3fff298d596ee2b 7bb4ae89666f1633270e1fce9c95d1b2
7377b35656204440c52e75b128f1f1df 19739034aaa79d2b5ae650d9626f83dd
2dfb9ec7b96d4951e0b12e93888ab290 3339caeb73227719b3d9cfbd33f5262f
a2f70cfe153d534fc00214f33349db4b 912f4990420f7c42eafda4141d234dd4
e70635988fb1026f1f1c5a7ab4e08bb3 8677de7826baece98a62ffecebe86faf
97595ef6e81a9a7e06b0b87d7d2ee947 95b6b121eb6034adebb63a7435d54246
bddfd3d3500388395e53731cfb952a7a 836db97dd11bed07661eb452ebc574d8
1658970f42229020afaa4b8587d1f474 112d02fff87553159e281b88798c5dfe
b0552ad764963379f3a576dc89c7b5dc eedbc95529c9de5bc69bdbe8f7b8f715
91844fc2e8eaf142559f0befb649184b 5429448f0c1814526b337c153e341ecc
076a59e35db15157710bd3a24585ae2b 9e7165a17f7e7ccaba03b3bbd2295e76
48c5e8fdbde2f120504adca18ceb7b09 0eeb7bc090e326119d18dcbd47dff68b
ff33d77adee646000e43b78227d5250f 689936cd43e310dd9340ffac9bd47add
84af28aeedbba7e0936b7901ca824afb 9629e2f91fa72ee5dc27c54244c37761
7bc1b3f23f83414a34afc732fd52db1b 00c1f535a02c15fd0fa745f6f6c6077c
09580a5670e99d3f8c2c11f663749eef 42080c14c953b1ddcc6d4663a7aa73f9
e47769247b7542ac20e5ca2b3dfce3ad d22142410736b3f020c348ddca0f3f3f
9b369109b9e7af39388599abc15be034 deeaf432377ae59c78caa043293b9075
5c4e7f908591bab62e21623b59d86119 e86e651fa35dc1428a7277e76f794551
ec696aeff081cfeb177c5393a166bdee 0bbf48035db86127eaf20212e1ce1520
39f5d5f5a848c4e4c6f39b025d7accac 6c0b7715b53ec2e08c8bee5d2184516d
fd7da75297b81b0dbe8cb8d3cd92013e e4da8e490f647cfc074717ef563ae23b
ee7182b30ac0f4fde8a9310babf1fd16 910791ba471cc5cabe2da2ece3c85030
16351467b81d117edf3be3bf7b0a54ff ea3173ff644a469ac8e02962abea2f55
d4e2b877cf4a0ec4e77813378b1f220e 073730b7f63803a7b1a4e866e58fd1af
c1e28895431a60318dd58eccfb7bd954 9608292e53c20662ca2bb5ff29f637f3
6bfcf844d4742aa86a1fdd6b40007a22 672f7e34e74fe047a4f62bc489d4153e
563677bc076a78738508bc5247f4cb10 18a52c8b01b5346992cd2f6b49bd5663
2996b0be4cda9b8a5d53eb63282f6a89 ec557d1d3659d3529be88456bc4cdb16
c1edd085489ada10fd3e34988c5554e9 52af510105933d08d9267d1abf635d21
36d08b0c796e95b195fd70ce5579dc94 3248be2014084e74a0fbfef860570009
230257db6e2e40dbe221f1278c317a88 7d588f4db0c64795b93763065952e657
656d5bb36b76c40cdf96cd816a8be541 5ada6af714c682277c6b14edd904572f
12b7d99df462959f8f789a68ba1d25ed 3e921f0f90d399fefa35d55ed1864f08
1cf3de3b61d2b143e78c5ed94c59e1fb 0caa9ec0af4370171eed43c8d9ae2fce
b64d2edb111c399d1a7b56e90b49bfe5
~~~


## Server Initial

The server sends the following payload in response, including an ACK frame, a
CRYPTO frame, and no PADDING frames:

~~~
02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739
88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94
0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00
020304
~~~

The header from the server includes a new connection ID and a 2-byte packet
number encoding for a packet number of 1:

~~~
d15a8e301a0008f067a5502a4262b50040750001
~~~

As a result, after protection, the header protection sample is taken starting
from the third protected byte:

~~~
sample = 25f69d3eaeaff6cd066a7efbb359883f
mask   = fb4da3a420
header = da5a8e301a0008f067a5502a4262b50040754da2
~~~

The final protected packet is then:

~~~
da5a8e301a0008f067a5502a4262b500 40754da2c4df25f69d3eaeaff6cd066a
7efbb359883fabb58b189ed18a1675f2 384911d5967a0d10f85dfd50870d0333
6bba01bf09b720cf4e3fe5b7d56e3c04 07ac6e7e40e56c646a2cb3de88774a31
a1c6676397732028a1540301523a185a 94c7c52d3b76f0f27854b0424cd90ac9
5a99b3f3ac58ed
~~~


## Retry

This shows a Retry packet that might be sent in response to the Initial packet
in {{sample-client-initial}}. The integrity check includes the client-chosen
connection ID value of 0x8394c8f03e515708, but that value is not
included in the final Retry packet:

~~~
cf5a8e301a0008f067a5502a4262b574 6f6b656e9af7959a3a8c237786aa863c
614ced91
~~~


## ChaCha20-Poly1305 Short Header Packet

This example shows some of the steps required to protect a packet with
a short header.  This example uses AEAD_CHACHA20_POLY1305.

In this example, TLS produces an application write secret from which a server
uses HKDF-Expand-Label to produce four values: a key, an IV, a header
protection key, and the secret that will be used after keys are updated (this
last value is not used further in this example).

~~~
secret
    = 9ac312a7f877468ebe69422748ad00a1
      5443f18203a07d6060f688f30f21632b

key = HKDF-Expand-Label(secret, "quicv2 key", "", 32)
    = 3bfcddd72bcf02541d7fa0dd1f5f9eee
      a817e09a6963a0e6c7df0f9a1bab90f2

iv  = HKDF-Expand-Label(secret, "quicv2 iv", "", 12)
    = a6b5bc6ab7dafce30ffff5dd

hp  = HKDF-Expand-Label(secret, "quicv2 hp", "", 32)
    = d659760d2ba434a226fd37b35c69e2da
      8211d10c4f12538787d65645d5d1b8e2

ku  = HKDF-Expand-Label(secret, "quicv2 ku", "", 32)
    = c69374c49e3d2a9466fa689e49d476db
      5d0dfbc87d32ceeaa6343fd0ae4c7d88
~~~

The following shows the steps involved in protecting a minimal packet with an
empty Destination Connection ID. This packet contains a single PING frame (that
is, a payload of just 0x01) and has a packet number of 654360564. In this
example, using a packet number of length 3 (that is, 49140 is encoded) avoids
having to pad the payload of the packet; PADDING frames would be needed if the
packet number is encoded on fewer bytes.

~~~
pn                 = 654360564 (decimal)
nonce              = a6b5bc6ab7dafce328ff4a29
unprotected header = 4200bff4
payload plaintext  = 01
payload ciphertext = 0ae7b6b932bc27d786f4bc2bb20f2162ba
~~~

The resulting ciphertext is the minimum size possible. One byte is skipped to
produce the sample for header protection.

~~~
sample = e7b6b932bc27d786f4bc2bb20f2162ba
mask   = 97580e32bf
header = 5558b1c6
~~~

The protected packet is the smallest possible packet size of 21 bytes.

~~~
packet = 5558b1c60ae7b6b932bc27d786f4bc2bb20f2162ba
~~~

# Acknowledgments

The author would like to thank Christian Huitema, Lucas Pardue, Kyle Rose,
Anthony Rossi, Zahed Sarker, David Schinazi, Tatsuhiro Tsujikawa, and Martin
Thomson for their helpful suggestions.

# Changelog

> **RFC Editor's Note:**  Please remove this section prior to
> publication of a final version of this document.

## since draft-ietf-quic-v2-06

* Clients MUST NOT use TLS resumption tickets across versions
* Servers SHOULD support multiple versions
* Clients SHOULD check path support for QUIC independently by version
* Minor editorial changes

## since draft-ietf-quic-v2-05

* Servers MUST use the negotiated version in Initials with CRYPTO frames.
* Clarified when clients "learn" the negotiated version as required in the VN
draft.
* Comments from SECDIR review.

## since draft-ietf-quic-v2-04

* Clarified 0-RTT handling
* Editorial comments from Zahed Sarker.

## since draft-ietf-quic-v2-03

* a v2 session ticket is an indication of v2 support
* a v1-only extension is theoretically possible
* editorial fixes

## since draft-ietf-quic-v2-02

* Editorial comments from Lucas Pardue

## since draft-ietf-quic-v2-01

* Ban use of NEW_TOKEN tokens across versions
* version-info transport parameter required for all v2 endpoints
* Explicitly list known ALPN compatibility

## since draft-ietf-quic-v2-00

* Expanded requirements for compatible version negotiation
* Added test vectors
* Greased the packet type codepoints
* Random version number
* Clarified requirement to use QUIC-VN
* Banned use of resumption tokens across versions

## since draft-duke-quic-v2-02

* Converted to adopted draft
* Deleted references to QUIC improvements
* Clarified status of QUIC extensions

## since draft-duke-quic-v2-01

* Made the final version number TBD.
* Added ALPN considerations

## since draft-duke-quic-v2-00

* Added provisional versions for interop
* Change the v1 Retry Tag secret
* Change labels to create full key separation
